"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const __1 = tslib_1.__importStar(require("../"));
test('Text with string children', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null, "You have 4 PRs"))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "You have 4 PRs",
                  },
                  "type": "String",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with function component children', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    const InProgressLozenge = () => __1.default.createElement(__1.StatusLozenge, { text: "In progress", appearance: "inprogress" });
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null,
        "You have ",
        __1.default.createElement(__1.Em, null, "4"),
        " ",
        __1.default.createElement(InProgressLozenge, null),
        " PRs"))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "You have ",
                  },
                  "type": "String",
                },
                {
                  "children": [
                    {
                      "children": [],
                      "props": {
                        "text": "4",
                      },
                      "type": "String",
                    },
                  ],
                  "key": "Em.0",
                  "props": {},
                  "type": "Em",
                },
                {
                  "children": [],
                  "props": {
                    "text": " ",
                  },
                  "type": "String",
                },
                {
                  "children": [],
                  "key": "StatusLozenge.0",
                  "props": {
                    "appearance": "inprogress",
                    "text": "In progress",
                  },
                  "type": "StatusLozenge",
                },
                {
                  "children": [],
                  "props": {
                    "text": " PRs",
                  },
                  "type": "String",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with function component fragment', async () => {
    const now = new Date('2020-02-16').getUTCMilliseconds();
    Date.now = jest.fn().mockReturnValue(now);
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    const InProgressLozenge = () => (__1.default.createElement(__1.Fragment, null,
        __1.default.createElement(__1.StatusLozenge, { text: "In progress", appearance: "inprogress" }),
        __1.default.createElement(__1.DateLozenge, { value: now })));
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null,
        "You have 4 ",
        __1.default.createElement(InProgressLozenge, null),
        " PRs"))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "You have 4 ",
                  },
                  "type": "String",
                },
                {
                  "children": [],
                  "key": "StatusLozenge.0",
                  "props": {
                    "appearance": "inprogress",
                    "text": "In progress",
                  },
                  "type": "StatusLozenge",
                },
                {
                  "children": [],
                  "key": "DateLozenge.0",
                  "props": {
                    "value": 0,
                  },
                  "type": "DateLozenge",
                },
                {
                  "children": [],
                  "props": {
                    "text": " PRs",
                  },
                  "type": "String",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with spaces between inline components', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null,
        __1.default.createElement(__1.StatusLozenge, { text: "ok", appearance: "success" }),
        " ",
        __1.default.createElement(__1.StatusLozenge, { text: "ok", appearance: "success" })))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "key": "StatusLozenge.0",
                  "props": {
                    "appearance": "success",
                    "text": "ok",
                  },
                  "type": "StatusLozenge",
                },
                {
                  "children": [],
                  "props": {
                    "text": " ",
                  },
                  "type": "String",
                },
                {
                  "children": [],
                  "key": "StatusLozenge.1",
                  "props": {
                    "appearance": "success",
                    "text": "ok",
                  },
                  "type": "StatusLozenge",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with markup format', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null, "This is some text content. The result should be a single node of type String."))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "This is some text content. The result should be a single node of type String.",
                  },
                  "type": "String",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with markup format and inline components', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null,
        "Hello this is a lozenge ",
        __1.default.createElement(__1.StatusLozenge, { text: "ok", appearance: "success" }),
        ' ',
        __1.default.createElement(__1.StatusLozenge, { text: "ok", appearance: "success" })))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "Hello this is a lozenge ",
                  },
                  "type": "String",
                },
                {
                  "children": [],
                  "key": "StatusLozenge.0",
                  "props": {
                    "appearance": "success",
                    "text": "ok",
                  },
                  "type": "StatusLozenge",
                },
                {
                  "children": [],
                  "props": {
                    "text": " ",
                  },
                  "type": "String",
                },
                {
                  "children": [],
                  "key": "StatusLozenge.1",
                  "props": {
                    "appearance": "success",
                    "text": "ok",
                  },
                  "type": "StatusLozenge",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with markup format and nested markup components', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    const Strong = 'Strong';
    const Em = 'Em';
    const Strikethrough = 'Strikethrough';
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null,
        "This is some ",
        __1.default.createElement(Strong, null, "bold text"),
        " and some ",
        __1.default.createElement(Em, null, "italic text"),
        ". Finally, some",
        ' ',
        __1.default.createElement(Strong, null,
            __1.default.createElement(Em, null, "bold and italic text"),
            " and ",
            __1.default.createElement(Strikethrough, null, "strikethrough"))))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "This is some ",
                  },
                  "type": "String",
                },
                {
                  "children": [
                    {
                      "children": [],
                      "props": {
                        "text": "bold text",
                      },
                      "type": "String",
                    },
                  ],
                  "key": "Strong.0",
                  "props": {},
                  "type": "Strong",
                },
                {
                  "children": [],
                  "props": {
                    "text": " and some ",
                  },
                  "type": "String",
                },
                {
                  "children": [
                    {
                      "children": [],
                      "props": {
                        "text": "italic text",
                      },
                      "type": "String",
                    },
                  ],
                  "key": "Em.0",
                  "props": {},
                  "type": "Em",
                },
                {
                  "children": [],
                  "props": {
                    "text": ". Finally, some",
                  },
                  "type": "String",
                },
                {
                  "children": [],
                  "props": {
                    "text": " ",
                  },
                  "type": "String",
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [],
                          "props": {
                            "text": "bold and italic text",
                          },
                          "type": "String",
                        },
                      ],
                      "key": "Em.1",
                      "props": {},
                      "type": "Em",
                    },
                    {
                      "children": [],
                      "props": {
                        "text": " and ",
                      },
                      "type": "String",
                    },
                    {
                      "children": [
                        {
                          "children": [],
                          "props": {
                            "text": "strikethrough",
                          },
                          "type": "String",
                        },
                      ],
                      "key": "Strikethrough.0",
                      "props": {},
                      "type": "Strikethrough",
                    },
                  ],
                  "key": "Strong.1",
                  "props": {},
                  "type": "Strong",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
test('Text with markup format and function components', async () => {
    const payload = {
        context: {},
        state: {},
        effects: [{ type: 'initialize' }],
        config: undefined
    };
    const Strong = 'Strong';
    const CustomMarkup = () => __1.default.createElement(Strong, null, "Custom bold text");
    expect(await (0, __1.render)(__1.default.createElement(__1.Text, null,
        "This is some ",
        __1.default.createElement(CustomMarkup, null)))(payload, {})).toMatchInlineSnapshot(`
    [
      {
        "aux": {
          "children": [
            {
              "children": [
                {
                  "children": [],
                  "props": {
                    "text": "This is some ",
                  },
                  "type": "String",
                },
                {
                  "children": [
                    {
                      "children": [],
                      "props": {
                        "text": "Custom bold text",
                      },
                      "type": "String",
                    },
                  ],
                  "key": "Strong.0",
                  "props": {},
                  "type": "Strong",
                },
              ],
              "key": "Text.0",
              "props": {
                "format": "markup",
              },
              "type": "Text",
            },
          ],
          "type": "View",
        },
        "state": {},
        "type": "render",
      },
    ]
  `);
});
